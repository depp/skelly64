{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Skelly 64 is a set of tools for creating assets for homebrew Nintendo 64 games. Warning This project is a work in progress. Skelly 64 is just not complete, or very usable yet. The tools were designed to be used in a game for the N64Brew Jam in 2020, and it will take time to document these tools, fix some bugs, and make them work for more general cases. While I\u2019d like to make these tools usable for your project, these tools aren\u2019t really ready yet! That\u2019s why I\u2019m creating these docs. I\u2019m looking forward to removing this section from the docs. Homebrew, or ROM Hack? Skelly 64 is only designed to help you create new homebrew games, it won\u2019t help you make ROM hacks, it won't help you modify existing games, and it won't help you use textures or models from old Nintendo 64 games. A homebrew game is a completely new game for the Nintendo 64, made long after the console was no longer supported. This means new code, new sound, new graphics. A ROM hack is a modification to an old Nintendo 64 game, like Super Mario 64 or Ocarina of Time. ROM hacks and homebrew games are just too different from each other. With homebrew games, you are free to design the game however you want, and Skelly 64 will help. However, if you are working on a ROM hack, you have to work with the existing formats used in old Nintendo 64 games. Skelly 64 does not support these formats, and support for these old formats will never be added. License The Skelly 64 project is licensed under the terms of the Mozilla Public License v2.0 .","title":"Introduction"},{"location":"#introduction","text":"Skelly 64 is a set of tools for creating assets for homebrew Nintendo 64 games. Warning This project is a work in progress. Skelly 64 is just not complete, or very usable yet. The tools were designed to be used in a game for the N64Brew Jam in 2020, and it will take time to document these tools, fix some bugs, and make them work for more general cases. While I\u2019d like to make these tools usable for your project, these tools aren\u2019t really ready yet! That\u2019s why I\u2019m creating these docs. I\u2019m looking forward to removing this section from the docs.","title":"Introduction"},{"location":"#homebrew-or-rom-hack","text":"Skelly 64 is only designed to help you create new homebrew games, it won\u2019t help you make ROM hacks, it won't help you modify existing games, and it won't help you use textures or models from old Nintendo 64 games. A homebrew game is a completely new game for the Nintendo 64, made long after the console was no longer supported. This means new code, new sound, new graphics. A ROM hack is a modification to an old Nintendo 64 game, like Super Mario 64 or Ocarina of Time. ROM hacks and homebrew games are just too different from each other. With homebrew games, you are free to design the game however you want, and Skelly 64 will help. However, if you are working on a ROM hack, you have to work with the existing formats used in old Nintendo 64 games. Skelly 64 does not support these formats, and support for these old formats will never be added.","title":"Homebrew, or ROM Hack?"},{"location":"#license","text":"The Skelly 64 project is licensed under the terms of the Mozilla Public License v2.0 .","title":"License"},{"location":"audio/","text":"Audio Converter Warning The audio converter does not work.","title":"Audio Converter"},{"location":"audio/#audio-converter","text":"Warning The audio converter does not work.","title":"Audio Converter"},{"location":"building/","text":"Building Skelly 64 is distributed as source code, you will need to compile the tools in order to use them. Prerequisites Bazel 4.1.0. Newer version should also work. Pkg-config , used to find Assimp and FreeType. SoX , used to convert audio data. Assimp , used to import 3D models. FreeType , used to convert fonts to bitmaps. Debian To install the prerequisites on Debian, run: sudo apt install build-essential sox libassimp-dev libfreetype-dev macOS (Homebrew) To install the prerequisites using Homebrew on macOS: brew install bazel pkg-config sox assimp freetype Building and Running You can build one of the tools by running Bazel. The first time you build a tool with Bazel, it will download some additional prerequisites, so you will need an active internet connection. For example, to build the font tool: bazel build -c opt //tools/font The -c opt tells Bazel to use the \u201coptimized build\u201d compilation mode, which enables compiler optimizations. This is recommended if you are just using the tools and not modifying them. Bazel will rebuild if you change this flag. You can build and run a tool with Bazel\u2019s run command: bazel run -c opt //tools/font To pass arguments to a tool, add -- to the end of the command, and put the arguments there (otherwise, Bazel will intercept the arguments). For example, to pass the -help flag to the font tool: bazel run -c opt //tools/font -- -help","title":"Building"},{"location":"building/#building","text":"Skelly 64 is distributed as source code, you will need to compile the tools in order to use them.","title":"Building"},{"location":"building/#prerequisites","text":"Bazel 4.1.0. Newer version should also work. Pkg-config , used to find Assimp and FreeType. SoX , used to convert audio data. Assimp , used to import 3D models. FreeType , used to convert fonts to bitmaps.","title":"Prerequisites"},{"location":"building/#debian","text":"To install the prerequisites on Debian, run: sudo apt install build-essential sox libassimp-dev libfreetype-dev","title":"Debian"},{"location":"building/#macos-homebrew","text":"To install the prerequisites using Homebrew on macOS: brew install bazel pkg-config sox assimp freetype","title":"macOS (Homebrew)"},{"location":"building/#building-and-running","text":"You can build one of the tools by running Bazel. The first time you build a tool with Bazel, it will download some additional prerequisites, so you will need an active internet connection. For example, to build the font tool: bazel build -c opt //tools/font The -c opt tells Bazel to use the \u201coptimized build\u201d compilation mode, which enables compiler optimizations. This is recommended if you are just using the tools and not modifying them. Bazel will rebuild if you change this flag. You can build and run a tool with Bazel\u2019s run command: bazel run -c opt //tools/font To pass arguments to a tool, add -- to the end of the command, and put the arguments there (otherwise, Bazel will intercept the arguments). For example, to pass the -help flag to the font tool: bazel run -c opt //tools/font -- -help","title":"Building and Running"},{"location":"font/","text":"Font Builder The font builder converts fonts to a format which can be used by the Nintendo 64. Warning Missing documentation. Input Formats Any font format supported by the FreeType library should work. TrueType (TTF) has been tested and is known to work.","title":"Font Builder"},{"location":"font/#font-builder","text":"The font builder converts fonts to a format which can be used by the Nintendo 64. Warning Missing documentation.","title":"Font Builder"},{"location":"font/#input-formats","text":"Any font format supported by the FreeType library should work. TrueType (TTF) has been tested and is known to work.","title":"Input Formats"},{"location":"image/","text":"Image Converter The image converter converts PNG images to a format which can be used by the Nintendo 64. Warning Missing documentation.","title":"Image Converter"},{"location":"image/#image-converter","text":"The image converter converts PNG images to a format which can be used by the Nintendo 64. Warning Missing documentation.","title":"Image Converter"},{"location":"model/","text":"Model Converter Warning Missing documentation. The model converter converts models from standard formats like FBX into formats suitable for the Nintendo 64 homebrew projects. The Bazel target is //tools/model . Running model -model <input> -output <output.model> Options -animate : Convert animations. -axes <axes> : Change the axes of the 3D model. This can be used to convert between left-handed and right-handed systems, or change which axis a model is facing towards. Defaults to x,y,z . (TODO: how does this work?) -meter <expr> : Define the length of a meter. The meter can be used by the -scale flag. The length can be a number or a simple numerical expression, such as -meter 100/64 . -model <input> : Use <input> as the input model. The input may be an FBX model. Other model formats may work, but are not tested. -output <output.model> : Write the model to <output.model> . The output is a custom format. -output-c <output.c> : Write the model as C source code to <output.c> . This may not work correctly and is not intended to be used in real games, but it shows the GBI commands used in the output model. -output-stats <output.log> : Write information about the model to <output.log> . This information is human-readable and should not be parsed. -scale <expr> : Scale the model by this factor. The factor can be a number or a numerical expression, and it can be defined in terms of the value for the -meter flag. For example, -scale 64/300 or -scale \"meter*10\" . -texcoord-bits <num> : Set the number of fractional bits of precision used for texture coordinates. Defaults to 11. -use-normals : Use vertex normals from model. Cannot be combined with vertex colors. -use-primitive-color : Use primitive color from material. (TODO: What part of the material?) -use-texcoords : Include texture coordinates. -use-vertex-colors : Include vertex colors. Cannot be combined with normals. -variable-name <name> : Use <name> as the name of the variable which contains the model data generated with -output-c . Building To build, bazel build -c opt //tools/model This will place the tool in bazel-bin/tools/model/model . Input Formats The converter supports the FBX format for input. Note The model converter uses the Open Asset Import Library , and in theory, can use other formats that the Open Asset Import Library supports. However, this is not tested. Note In the future, glTF may become the recommended format.","title":"Overview"},{"location":"model/#model-converter","text":"Warning Missing documentation. The model converter converts models from standard formats like FBX into formats suitable for the Nintendo 64 homebrew projects. The Bazel target is //tools/model .","title":"Model Converter"},{"location":"model/#running","text":"model -model <input> -output <output.model>","title":"Running"},{"location":"model/#options","text":"-animate : Convert animations. -axes <axes> : Change the axes of the 3D model. This can be used to convert between left-handed and right-handed systems, or change which axis a model is facing towards. Defaults to x,y,z . (TODO: how does this work?) -meter <expr> : Define the length of a meter. The meter can be used by the -scale flag. The length can be a number or a simple numerical expression, such as -meter 100/64 . -model <input> : Use <input> as the input model. The input may be an FBX model. Other model formats may work, but are not tested. -output <output.model> : Write the model to <output.model> . The output is a custom format. -output-c <output.c> : Write the model as C source code to <output.c> . This may not work correctly and is not intended to be used in real games, but it shows the GBI commands used in the output model. -output-stats <output.log> : Write information about the model to <output.log> . This information is human-readable and should not be parsed. -scale <expr> : Scale the model by this factor. The factor can be a number or a numerical expression, and it can be defined in terms of the value for the -meter flag. For example, -scale 64/300 or -scale \"meter*10\" . -texcoord-bits <num> : Set the number of fractional bits of precision used for texture coordinates. Defaults to 11. -use-normals : Use vertex normals from model. Cannot be combined with vertex colors. -use-primitive-color : Use primitive color from material. (TODO: What part of the material?) -use-texcoords : Include texture coordinates. -use-vertex-colors : Include vertex colors. Cannot be combined with normals. -variable-name <name> : Use <name> as the name of the variable which contains the model data generated with -output-c .","title":"Options"},{"location":"model/#building","text":"To build, bazel build -c opt //tools/model This will place the tool in bazel-bin/tools/model/model .","title":"Building"},{"location":"model/#input-formats","text":"The converter supports the FBX format for input. Note The model converter uses the Open Asset Import Library , and in theory, can use other formats that the Open Asset Import Library supports. However, this is not tested. Note In the future, glTF may become the recommended format.","title":"Input Formats"},{"location":"model_format/","text":"Model Format Warning This project is in-progress, and the format may change. The model format consists of three sections: Header Main data Vertex data All values are stored in big endian. Any pointers in C structures are serialized as offsets measured from the start of the same section. Header Offset Type Description 0 byte[4] Magic 16 uint32 Main data offset 20 uint32 Main data size 24 uint32 Vertex data offset 28 uint32 Vertex data size The \u201cmagic\u201d identifies this file type, and it consists of the ASCII string \u201cModel\u201d followed by null bytes. The remaining fields locate the other sections in the file. The remaining fields describe where the other sections are. Offsets are measured from the beginning of the file. Main Data The main data contains the display lists and various metadata like timing information. enum { MATERIAL_SLOTS = 4, }; struct model_header { Vtx *vertex_data; Gfx *display_list[MATERIAL_SLOTS]; int animation_count; unsigned frame_size; struct model_animation animation[]; }; Offset Type Description 0 uint32 Non-animated vertex data offset 4 uint32[4] Display list offset 20 uint32 Number of animations 24 uint32 Frame vertex data size 28 animdata[] Animation data The non-animated vertex data offset is the relative offset, from the start of the main data section, of the default vertex data. In the current tool, the vertex data is always present. It is not needed for animations, but used instead for non-animated models. The display list offsets are the relative offsets, from the start of the main data section, of the display lists for each material in the model. Four materials are supported per model. The display lists refer to vertex data through segment 1. It is assumed that segment 1 points to the beginning of the vertex data for the current animation frame. The animation count gives the size of the animation data array. The frame vertex data size is the size, in bytes, of the vertex data for a single frame. Animation Data The animation data array consists of items with this structure: struct model_animation { float duration; int frame_count; struct model_frame *frame; }; Offset Type Description 0 float32 Duration (seconds) 4 uint32 Frame count 8 uint32 Offset of first frame The offset of the first frame is measured from the beginning of the main data section. It contains an array of frame data. Frame Data The metadata for each frame is stored in frame data structures. struct model_frame { float time; float inv_dt; unsigned vertex; }; Offset Type Description 0 float32 Duration (seconds) 4 float32 Inverse of duration (1/seconds) 8 uint32 Vertex data offset The vertex data offset is relative to the start of the vertex data section. Vertex Data The vertex data consists of the vertex data for each frame of animation, an array of Vtx . A frame can be selected by mapping the vertex data for that frame into segment 1.","title":"Format"},{"location":"model_format/#model-format","text":"Warning This project is in-progress, and the format may change. The model format consists of three sections: Header Main data Vertex data All values are stored in big endian. Any pointers in C structures are serialized as offsets measured from the start of the same section.","title":"Model Format"},{"location":"model_format/#header","text":"Offset Type Description 0 byte[4] Magic 16 uint32 Main data offset 20 uint32 Main data size 24 uint32 Vertex data offset 28 uint32 Vertex data size The \u201cmagic\u201d identifies this file type, and it consists of the ASCII string \u201cModel\u201d followed by null bytes. The remaining fields locate the other sections in the file. The remaining fields describe where the other sections are. Offsets are measured from the beginning of the file.","title":"Header"},{"location":"model_format/#main-data","text":"The main data contains the display lists and various metadata like timing information. enum { MATERIAL_SLOTS = 4, }; struct model_header { Vtx *vertex_data; Gfx *display_list[MATERIAL_SLOTS]; int animation_count; unsigned frame_size; struct model_animation animation[]; }; Offset Type Description 0 uint32 Non-animated vertex data offset 4 uint32[4] Display list offset 20 uint32 Number of animations 24 uint32 Frame vertex data size 28 animdata[] Animation data The non-animated vertex data offset is the relative offset, from the start of the main data section, of the default vertex data. In the current tool, the vertex data is always present. It is not needed for animations, but used instead for non-animated models. The display list offsets are the relative offsets, from the start of the main data section, of the display lists for each material in the model. Four materials are supported per model. The display lists refer to vertex data through segment 1. It is assumed that segment 1 points to the beginning of the vertex data for the current animation frame. The animation count gives the size of the animation data array. The frame vertex data size is the size, in bytes, of the vertex data for a single frame.","title":"Main Data"},{"location":"model_format/#animation-data","text":"The animation data array consists of items with this structure: struct model_animation { float duration; int frame_count; struct model_frame *frame; }; Offset Type Description 0 float32 Duration (seconds) 4 uint32 Frame count 8 uint32 Offset of first frame The offset of the first frame is measured from the beginning of the main data section. It contains an array of frame data.","title":"Animation Data"},{"location":"model_format/#frame-data","text":"The metadata for each frame is stored in frame data structures. struct model_frame { float time; float inv_dt; unsigned vertex; }; Offset Type Description 0 float32 Duration (seconds) 4 float32 Inverse of duration (1/seconds) 8 uint32 Vertex data offset The vertex data offset is relative to the start of the vertex data section.","title":"Frame Data"},{"location":"model_format/#vertex-data","text":"The vertex data consists of the vertex data for each frame of animation, an array of Vtx . A frame can be selected by mapping the vertex data for that frame into segment 1.","title":"Vertex Data"},{"location":"rom/","text":"ROM Tool The ROM tool creates a Nintendo 64 ROM image from an ELF executable file. Warning Missing documentation.","title":"ROM Tool"},{"location":"rom/#rom-tool","text":"The ROM tool creates a Nintendo 64 ROM image from an ELF executable file. Warning Missing documentation.","title":"ROM Tool"}]}