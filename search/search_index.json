{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Skelly 64 is a set of tools for creating assets for homebrew Nintendo 64 games. Warning This project is a work in progress. Skelly 64 is just not complete, or very usable yet. The tools were designed to be used in a game for the N64Brew Jam in 2020, and it will take time to document these tools, fix some bugs, and make them work for more general cases. While I\u2019d like to make these tools usable for your project, these tools aren\u2019t really ready yet! That\u2019s why I\u2019m creating these docs. I\u2019m looking forward to removing this section from the docs. Homebrew, or ROM Hack? Skelly 64 is only designed to help you create new homebrew games, it won\u2019t help you make ROM hacks, it won't help you modify existing games, and it won't help you use textures or models from old Nintendo 64 games. A homebrew game is a completely new game for the Nintendo 64, made long after the console was no longer supported. This means new code, new sound, new graphics. A ROM hack is a modification to an old Nintendo 64 game, like Super Mario 64 or Ocarina of Time. ROM hacks and homebrew games are just too different from each other. With homebrew games, you are free to design the game however you want, and Skelly 64 will help. However, if you are working on a ROM hack, you have to work with the existing formats used in old Nintendo 64 games. Skelly 64 does not support these formats, and support for these old formats will never be added. License The Skelly 64 project is licensed under the terms of the Mozilla Public License v2.0 .","title":"Introduction"},{"location":"#introduction","text":"Skelly 64 is a set of tools for creating assets for homebrew Nintendo 64 games. Warning This project is a work in progress. Skelly 64 is just not complete, or very usable yet. The tools were designed to be used in a game for the N64Brew Jam in 2020, and it will take time to document these tools, fix some bugs, and make them work for more general cases. While I\u2019d like to make these tools usable for your project, these tools aren\u2019t really ready yet! That\u2019s why I\u2019m creating these docs. I\u2019m looking forward to removing this section from the docs.","title":"Introduction"},{"location":"#homebrew-or-rom-hack","text":"Skelly 64 is only designed to help you create new homebrew games, it won\u2019t help you make ROM hacks, it won't help you modify existing games, and it won't help you use textures or models from old Nintendo 64 games. A homebrew game is a completely new game for the Nintendo 64, made long after the console was no longer supported. This means new code, new sound, new graphics. A ROM hack is a modification to an old Nintendo 64 game, like Super Mario 64 or Ocarina of Time. ROM hacks and homebrew games are just too different from each other. With homebrew games, you are free to design the game however you want, and Skelly 64 will help. However, if you are working on a ROM hack, you have to work with the existing formats used in old Nintendo 64 games. Skelly 64 does not support these formats, and support for these old formats will never be added.","title":"Homebrew, or ROM Hack?"},{"location":"#license","text":"The Skelly 64 project is licensed under the terms of the Mozilla Public License v2.0 .","title":"License"},{"location":"audio/","text":"Audio Converter Warning The audio converter does not work.","title":"Audio Converter"},{"location":"audio/#audio-converter","text":"Warning The audio converter does not work.","title":"Audio Converter"},{"location":"building/","text":"Building Skelly 64 is distributed as source code, you will need to compile the tools in order to use them. Prerequisites Bazel 4.1.0. Newer version should also work. Pkg-config , used to find Assimp and FreeType. SoX , used to convert audio data. Assimp , used to import 3D models. FreeType , used to convert fonts to bitmaps. Debian To install the prerequisites on Debian, run: sudo apt install build-essential sox libassimp-dev libfreetype-dev macOS (Homebrew) To install the prerequisites using Homebrew on macOS: brew install bazel pkg-config sox assimp freetype Building and Running You can build one of the tools by running Bazel. The first time you build a tool with Bazel, it will download some additional prerequisites, so you will need an active internet connection. For example, to build the font tool: bazel build -c opt //tools/font The -c opt tells Bazel to use the \u201coptimized build\u201d compilation mode, which enables compiler optimizations. This is recommended if you are just using the tools and not modifying them. Bazel will rebuild if you change this flag. You can build and run a tool with Bazel\u2019s run command: bazel run -c opt //tools/font To pass arguments to a tool, add -- to the end of the command, and put the arguments there (otherwise, Bazel will intercept the arguments). For example, to pass the -help flag to the font tool: bazel run -c opt //tools/font -- -help","title":"Building"},{"location":"building/#building","text":"Skelly 64 is distributed as source code, you will need to compile the tools in order to use them.","title":"Building"},{"location":"building/#prerequisites","text":"Bazel 4.1.0. Newer version should also work. Pkg-config , used to find Assimp and FreeType. SoX , used to convert audio data. Assimp , used to import 3D models. FreeType , used to convert fonts to bitmaps.","title":"Prerequisites"},{"location":"building/#debian","text":"To install the prerequisites on Debian, run: sudo apt install build-essential sox libassimp-dev libfreetype-dev","title":"Debian"},{"location":"building/#macos-homebrew","text":"To install the prerequisites using Homebrew on macOS: brew install bazel pkg-config sox assimp freetype","title":"macOS (Homebrew)"},{"location":"building/#building-and-running","text":"You can build one of the tools by running Bazel. The first time you build a tool with Bazel, it will download some additional prerequisites, so you will need an active internet connection. For example, to build the font tool: bazel build -c opt //tools/font The -c opt tells Bazel to use the \u201coptimized build\u201d compilation mode, which enables compiler optimizations. This is recommended if you are just using the tools and not modifying them. Bazel will rebuild if you change this flag. You can build and run a tool with Bazel\u2019s run command: bazel run -c opt //tools/font To pass arguments to a tool, add -- to the end of the command, and put the arguments there (otherwise, Bazel will intercept the arguments). For example, to pass the -help flag to the font tool: bazel run -c opt //tools/font -- -help","title":"Building and Running"},{"location":"image/","text":"Image Converter The image converter converts PNG images to a format which can be used by the Nintendo 64. Warning Missing documentation.","title":"Image Converter"},{"location":"image/#image-converter","text":"The image converter converts PNG images to a format which can be used by the Nintendo 64. Warning Missing documentation.","title":"Image Converter"},{"location":"model/","text":"Model Converter Warning Missing documentation. The model converter converts models from standard formats like FBX into formats suitable for the Nintendo 64 homebrew projects. The Bazel target is //tools/model . Running model -model <input> -output <output.model> Options -animate : Convert animations. -axes <axes> : Change the axes of the 3D model. This can be used to convert between left-handed and right-handed systems, or change which axis a model is facing towards. Defaults to x,y,z . (TODO: how does this work?) -meter <expr> : Define the length of a meter. The meter can be used by the -scale flag. The length can be a number or a simple numerical expression, such as -meter 100/64 . -model <input> : Use <input> as the input model. The input may be an FBX model. Other model formats may work, but are not tested. -output <output.model> : Write the model to <output.model> . The output is a custom format. -output-c <output.c> : Write the model as C source code to <output.c> . This may not work correctly and is not intended to be used in real games, but it shows the GBI commands used in the output model. -output-stats <output.log> : Write information about the model to <output.log> . This information is human-readable and should not be parsed. -scale <expr> : Scale the model by this factor. The factor can be a number or a numerical expression, and it can be defined in terms of the value for the -meter flag. For example, -scale 64/300 or -scale \"meter*10\" . -texcoord-bits <num> : Set the number of fractional bits of precision used for texture coordinates. Defaults to 11. -use-normals : Use vertex normals from model. Cannot be combined with vertex colors. -use-primitive-color : Use primitive color from material. (TODO: What part of the material?) -use-texcoords : Include texture coordinates. -use-vertex-colors : Include vertex colors. Cannot be combined with normals. -variable-name <name> : Use <name> as the name of the variable which contains the model data generated with -output-c . Building To build, bazel build -c opt //tools/model This will place the tool in bazel-bin/tools/model/model . Input Formats The converter supports the FBX format for input. Note The model converter uses the Open Asset Import Library , and in theory, can use other formats that the Open Asset Import Library supports. However, this is not tested. Note In the future, glTF may become the recommended format.","title":"Overview"},{"location":"model/#model-converter","text":"Warning Missing documentation. The model converter converts models from standard formats like FBX into formats suitable for the Nintendo 64 homebrew projects. The Bazel target is //tools/model .","title":"Model Converter"},{"location":"model/#running","text":"model -model <input> -output <output.model>","title":"Running"},{"location":"model/#options","text":"-animate : Convert animations. -axes <axes> : Change the axes of the 3D model. This can be used to convert between left-handed and right-handed systems, or change which axis a model is facing towards. Defaults to x,y,z . (TODO: how does this work?) -meter <expr> : Define the length of a meter. The meter can be used by the -scale flag. The length can be a number or a simple numerical expression, such as -meter 100/64 . -model <input> : Use <input> as the input model. The input may be an FBX model. Other model formats may work, but are not tested. -output <output.model> : Write the model to <output.model> . The output is a custom format. -output-c <output.c> : Write the model as C source code to <output.c> . This may not work correctly and is not intended to be used in real games, but it shows the GBI commands used in the output model. -output-stats <output.log> : Write information about the model to <output.log> . This information is human-readable and should not be parsed. -scale <expr> : Scale the model by this factor. The factor can be a number or a numerical expression, and it can be defined in terms of the value for the -meter flag. For example, -scale 64/300 or -scale \"meter*10\" . -texcoord-bits <num> : Set the number of fractional bits of precision used for texture coordinates. Defaults to 11. -use-normals : Use vertex normals from model. Cannot be combined with vertex colors. -use-primitive-color : Use primitive color from material. (TODO: What part of the material?) -use-texcoords : Include texture coordinates. -use-vertex-colors : Include vertex colors. Cannot be combined with normals. -variable-name <name> : Use <name> as the name of the variable which contains the model data generated with -output-c .","title":"Options"},{"location":"model/#building","text":"To build, bazel build -c opt //tools/model This will place the tool in bazel-bin/tools/model/model .","title":"Building"},{"location":"model/#input-formats","text":"The converter supports the FBX format for input. Note The model converter uses the Open Asset Import Library , and in theory, can use other formats that the Open Asset Import Library supports. However, this is not tested. Note In the future, glTF may become the recommended format.","title":"Input Formats"},{"location":"model_format/","text":"Model Format Warning This project is in-progress, and the format may change. The model format consists of three sections: Header Main data Vertex data All values are stored in big endian. Any pointers in C structures are serialized as offsets measured from the start of the same section. Header Offset Type Description 0 byte[4] Magic 16 uint32 Main data offset 20 uint32 Main data size 24 uint32 Vertex data offset 28 uint32 Vertex data size The \u201cmagic\u201d identifies this file type, and it consists of the ASCII string \u201cModel\u201d followed by null bytes. The remaining fields locate the other sections in the file. The remaining fields describe where the other sections are. Offsets are measured from the beginning of the file. Main Data The main data contains the display lists and various metadata like timing information. enum { MATERIAL_SLOTS = 4, }; struct model_header { Vtx *vertex_data; Gfx *display_list[MATERIAL_SLOTS]; int animation_count; unsigned frame_size; struct model_animation animation[]; }; Offset Type Description 0 uint32 Non-animated vertex data offset 4 uint32[4] Display list offset 20 uint32 Number of animations 24 uint32 Frame vertex data size 28 animdata[] Animation data The non-animated vertex data offset is the relative offset, from the start of the main data section, of the default vertex data. In the current tool, the vertex data is always present. It is not needed for animations, but used instead for non-animated models. The display list offsets are the relative offsets, from the start of the main data section, of the display lists for each material in the model. Four materials are supported per model. The display lists refer to vertex data through segment 1. It is assumed that segment 1 points to the beginning of the vertex data for the current animation frame. The animation count gives the size of the animation data array. The frame vertex data size is the size, in bytes, of the vertex data for a single frame. Animation Data The animation data array consists of items with this structure: struct model_animation { float duration; int frame_count; struct model_frame *frame; }; Offset Type Description 0 float32 Duration (seconds) 4 uint32 Frame count 8 uint32 Offset of first frame The offset of the first frame is measured from the beginning of the main data section. It contains an array of frame data. Frame Data The metadata for each frame is stored in frame data structures. struct model_frame { float time; float inv_dt; unsigned vertex; }; Offset Type Description 0 float32 Duration (seconds) 4 float32 Inverse of duration (1/seconds) 8 uint32 Vertex data offset The vertex data offset is relative to the start of the vertex data section. Vertex Data The vertex data consists of the vertex data for each frame of animation, an array of Vtx . A frame can be selected by mapping the vertex data for that frame into segment 1.","title":"Format"},{"location":"model_format/#model-format","text":"Warning This project is in-progress, and the format may change. The model format consists of three sections: Header Main data Vertex data All values are stored in big endian. Any pointers in C structures are serialized as offsets measured from the start of the same section.","title":"Model Format"},{"location":"model_format/#header","text":"Offset Type Description 0 byte[4] Magic 16 uint32 Main data offset 20 uint32 Main data size 24 uint32 Vertex data offset 28 uint32 Vertex data size The \u201cmagic\u201d identifies this file type, and it consists of the ASCII string \u201cModel\u201d followed by null bytes. The remaining fields locate the other sections in the file. The remaining fields describe where the other sections are. Offsets are measured from the beginning of the file.","title":"Header"},{"location":"model_format/#main-data","text":"The main data contains the display lists and various metadata like timing information. enum { MATERIAL_SLOTS = 4, }; struct model_header { Vtx *vertex_data; Gfx *display_list[MATERIAL_SLOTS]; int animation_count; unsigned frame_size; struct model_animation animation[]; }; Offset Type Description 0 uint32 Non-animated vertex data offset 4 uint32[4] Display list offset 20 uint32 Number of animations 24 uint32 Frame vertex data size 28 animdata[] Animation data The non-animated vertex data offset is the relative offset, from the start of the main data section, of the default vertex data. In the current tool, the vertex data is always present. It is not needed for animations, but used instead for non-animated models. The display list offsets are the relative offsets, from the start of the main data section, of the display lists for each material in the model. Four materials are supported per model. The display lists refer to vertex data through segment 1. It is assumed that segment 1 points to the beginning of the vertex data for the current animation frame. The animation count gives the size of the animation data array. The frame vertex data size is the size, in bytes, of the vertex data for a single frame.","title":"Main Data"},{"location":"model_format/#animation-data","text":"The animation data array consists of items with this structure: struct model_animation { float duration; int frame_count; struct model_frame *frame; }; Offset Type Description 0 float32 Duration (seconds) 4 uint32 Frame count 8 uint32 Offset of first frame The offset of the first frame is measured from the beginning of the main data section. It contains an array of frame data.","title":"Animation Data"},{"location":"model_format/#frame-data","text":"The metadata for each frame is stored in frame data structures. struct model_frame { float time; float inv_dt; unsigned vertex; }; Offset Type Description 0 float32 Duration (seconds) 4 float32 Inverse of duration (1/seconds) 8 uint32 Vertex data offset The vertex data offset is relative to the start of the vertex data section.","title":"Frame Data"},{"location":"model_format/#vertex-data","text":"The vertex data consists of the vertex data for each frame of animation, an array of Vtx . A frame can be selected by mapping the vertex data for that frame into segment 1.","title":"Vertex Data"},{"location":"rom/","text":"ROM Tool The ROM tool creates a Nintendo 64 ROM image from an ELF executable file. Warning Missing documentation.","title":"ROM Tool"},{"location":"rom/#rom-tool","text":"The ROM tool creates a Nintendo 64 ROM image from an ELF executable file. Warning Missing documentation.","title":"ROM Tool"},{"location":"font/","text":"Font Builder The font builder converts fonts to a format which can be used by the Nintendo 64. Features Supports most font formats. Uses the FreeType library, which supports common formats like TTF and OTF, as well as more obscure formats like BDF. Produces two types of fonts. \u201cTexture fonts\u201d are fonts designed to be loaded into texture memory (TMEM) on the RDP, and drawn by the RDP. \u201cFallback fonts\u201d are designed to be drawn by the CPU, for example, if you want to draw something on-screen from a crash handler. Includes only a subset of the glyphs in a font. You can choose which glyphs that you want, like A-Z, 0-9, and the punctuation you need. This reduces the amount of data you have to load into TMEM. Supports different character encodings. You can use Unicode, or a more convenient encoding like Windows-1252 or Latin-1. Adds shadows to the font, if desired. Running font -font <input> -font-size <size> [-out-data <output.font>] [<option>...] Font Options These options control how fonts are loaded, rendered to bitmaps, and transformed. -case <upper|lower> : Transform all text to upper-case or lower-case. -charset <file> : Only use a subset of the font, including characters from a character set file. -encoding <name> : Specify the character encoding. Only simple 8-bit character encodings are supported. By default, the glyphs are encoded as their Unicode code points. -font <input> : Read the font from <input> . Most font formats supported by the FreeType library should work. TrueType (TTF) has been tested and is known to work, as well as Adobe BDF. -font-size <size> : Render the font at <size> pixels. -mono : Render the font outline as monochrome (1-bit), with no antialiasing. -out-grid <file.png> : After loading the font and applying all transformations, arrange the glyphs in a grid and write it to <file.png> . -remove-notdef : Remove the .notdef glyph from the font, used for missing or undefined glyphs. When specified, missing or undefined glyphs will skipped, as if they were not present in the input. Otherwise, they will usually be rendered as little squares. -shadow <x>:<y>[:<alpha>] : Bake a drop shadow into the font texture. Increasing X values move the shadow farther right, and increasing Y values move the shadow farther down. Alpha should be between 0.0 and 1.0, and defaults to 1.0. Texture Font Output These options control how texture fonts are produced. Texture fonts are intended to be loaded into texture memory in the Nintendo 64\u2019s RDP, and rendered using RDP commands (either using RSP microcode, or by issuing RDP commands directly). -format <format> : Use <format> as the pixel format for the texture. This must be a texture format that the RDP supports (note: CI is not currently supported). -out-data <out.font> : Write the bitmap font out to a data file, using the Skelly 64 font file. -out-texture <out.png> : Combine the font\u2019s textures into a single PNG file, and write it out. Used for previewing what the glyphs look like, and seeing how they are packed. -texture-size <width>:<height> : Specify the size of each texture. Fallback Font Output -out-fallback <file.h> : Write the fallback font as C source code to <file.h> . Texture Formats The tool supports nine different texture formats, listed below: Bits RGBA CI IA I 32 rgba.32 16 rgba.16 ia.16 8 ci.8 ia.8 i.8 4 ci.4 ia.4 i.4 The format can be chosen with the -format option. Note that there is no meaningful way to use color index formats at the moment. Charset Note Missing documentation\u2014how to specify the charset.","title":"Overview"},{"location":"font/#font-builder","text":"The font builder converts fonts to a format which can be used by the Nintendo 64.","title":"Font Builder"},{"location":"font/#features","text":"Supports most font formats. Uses the FreeType library, which supports common formats like TTF and OTF, as well as more obscure formats like BDF. Produces two types of fonts. \u201cTexture fonts\u201d are fonts designed to be loaded into texture memory (TMEM) on the RDP, and drawn by the RDP. \u201cFallback fonts\u201d are designed to be drawn by the CPU, for example, if you want to draw something on-screen from a crash handler. Includes only a subset of the glyphs in a font. You can choose which glyphs that you want, like A-Z, 0-9, and the punctuation you need. This reduces the amount of data you have to load into TMEM. Supports different character encodings. You can use Unicode, or a more convenient encoding like Windows-1252 or Latin-1. Adds shadows to the font, if desired.","title":"Features"},{"location":"font/#running","text":"font -font <input> -font-size <size> [-out-data <output.font>] [<option>...]","title":"Running"},{"location":"font/#font-options","text":"These options control how fonts are loaded, rendered to bitmaps, and transformed. -case <upper|lower> : Transform all text to upper-case or lower-case. -charset <file> : Only use a subset of the font, including characters from a character set file. -encoding <name> : Specify the character encoding. Only simple 8-bit character encodings are supported. By default, the glyphs are encoded as their Unicode code points. -font <input> : Read the font from <input> . Most font formats supported by the FreeType library should work. TrueType (TTF) has been tested and is known to work, as well as Adobe BDF. -font-size <size> : Render the font at <size> pixels. -mono : Render the font outline as monochrome (1-bit), with no antialiasing. -out-grid <file.png> : After loading the font and applying all transformations, arrange the glyphs in a grid and write it to <file.png> . -remove-notdef : Remove the .notdef glyph from the font, used for missing or undefined glyphs. When specified, missing or undefined glyphs will skipped, as if they were not present in the input. Otherwise, they will usually be rendered as little squares. -shadow <x>:<y>[:<alpha>] : Bake a drop shadow into the font texture. Increasing X values move the shadow farther right, and increasing Y values move the shadow farther down. Alpha should be between 0.0 and 1.0, and defaults to 1.0.","title":"Font Options"},{"location":"font/#texture-font-output","text":"These options control how texture fonts are produced. Texture fonts are intended to be loaded into texture memory in the Nintendo 64\u2019s RDP, and rendered using RDP commands (either using RSP microcode, or by issuing RDP commands directly). -format <format> : Use <format> as the pixel format for the texture. This must be a texture format that the RDP supports (note: CI is not currently supported). -out-data <out.font> : Write the bitmap font out to a data file, using the Skelly 64 font file. -out-texture <out.png> : Combine the font\u2019s textures into a single PNG file, and write it out. Used for previewing what the glyphs look like, and seeing how they are packed. -texture-size <width>:<height> : Specify the size of each texture.","title":"Texture Font Output"},{"location":"font/#fallback-font-output","text":"-out-fallback <file.h> : Write the fallback font as C source code to <file.h> .","title":"Fallback Font Output"},{"location":"font/#texture-formats","text":"The tool supports nine different texture formats, listed below: Bits RGBA CI IA I 32 rgba.32 16 rgba.16 ia.16 8 ci.8 ia.8 i.8 4 ci.4 ia.4 i.4 The format can be chosen with the -format option. Note that there is no meaningful way to use color index formats at the moment.","title":"Texture Formats"},{"location":"font/#charset","text":"Note Missing documentation\u2014how to specify the charset.","title":"Charset"},{"location":"font/ttf_example/","text":"TTF Example This is a subset of the Alegreya Medium font, rendered at size 16. The build scripts and data used to create this example are in the examples/font_ttf folder. The packed textures Note Missing documentation\u2014how was this created?","title":"TTF Example"},{"location":"font/ttf_example/#ttf-example","text":"This is a subset of the Alegreya Medium font, rendered at size 16. The build scripts and data used to create this example are in the examples/font_ttf folder. The packed textures Note Missing documentation\u2014how was this created?","title":"TTF Example"}]}