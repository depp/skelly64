package main

import (
	"bytes"
	"errors"
	"fmt"
	"os"
)

func (fn *font) makeFallback() ([]byte, error) {
	const (
		start = 32
		end   = 128
		count = end - start
	)
	glyphs := make([]*glyph, count)
	var hasGlyph bool
	for c, gi := range fn.charmap {
		if start <= c && c < end {
			hasGlyph = true
			glyphs[c-start] = fn.glyphs[gi]
		}
	}
	if !hasGlyph {
		return nil, errors.New("no characters below 128 for fallback font")
	}
	sy := fn.metrics.ascender - fn.metrics.descender
	if sy <= 0 {
		return nil, fmt.Errorf("invalid metrics: ascender = %d, descender = %d",
			fn.metrics.ascender, fn.metrics.descender)
	}
	var sx int32
	for _, g := range glyphs {
		if g != nil {
			sx = g.advance
			break
		}
	}
	for _, g := range glyphs {
		if g != nil && g.advance != sx {
			fmt.Fprintln(os.Stderr, "Warning: font is not monospace")
		}
	}
	if sx > 32 {
		return nil, fmt.Errorf("font too wide for fallback font: %d pixels, must be <= 32", sx)
	}
	bitmap := make([]uint32, sy*count)
	for i, g := range glyphs {
		if g != nil {
			yoff := g.center[1] - fn.metrics.ascender
			xoff := g.center[0]
			for y := int32(0); y < sy; y++ {
				var row uint32
				for x := int32(0); x < sx; x++ {
					c := g.image.RGBAAt(int(x+xoff), int(y+yoff))
					row |= (uint32(c.R) >> 7) << x
				}
				bitmap[int32(i)*sy+y] = row
			}
		}
	}
	var atype string
	switch {
	case sx <= 8:
		atype = "uint8_t"
	case sx <= 16:
		atype = "uint16_t"
	default:
		atype = "uint32_t"
	}
	var buf bytes.Buffer
	buf.WriteString("/* This file is automatically generated */\n")
	buf.WriteString("#include <stdint.h>\n")
	buf.WriteString("enum {\n")
	fmt.Fprintf(&buf, "    FONT_START = %d,\n", start)
	fmt.Fprintf(&buf, "    FONT_END = %d,\n", end)
	fmt.Fprint(&buf, "    FONT_NCHARS = FONT_END - FONT_START,\n")
	fmt.Fprintf(&buf, "    FONT_WIDTH = %d,\n", sx)
	fmt.Fprintf(&buf, "    FONT_HEIGHT = %d,\n", sy)
	buf.WriteString("};\n")
	buf.WriteString("#if INCLUDE_FONT_DATA\n")
	fmt.Fprintf(&buf, "static const %s FONT_DATA[FONT_HEIGHT * FONT_NCHARS] = {\n", atype)
	for i := int32(0); i < count; i++ {
		sep := "    "
		for _, d := range bitmap[i*sy : (i+1)*sy] {
			fmt.Fprintf(&buf, "%s%d,", sep, d)
			sep = ""
		}
		buf.WriteByte('\n')
	}
	buf.WriteString("};\n")
	buf.WriteString("#endif\n")
	return buf.Bytes(), nil
}
