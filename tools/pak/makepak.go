package main

import (
	"bufio"
	"bytes"
	"encoding/binary"
	"errors"
	"flag"
	"fmt"
	"io/ioutil"
	"os"
	"path"
	"path/filepath"
	"regexp"
	"strings"
	"text/template"
	"unicode/utf8"
)

var jobsFlag int

var validIdent = regexp.MustCompile("^[A-Za-z][A-Za-z0-9_]*$")

type entry struct {
	Ident    string
	Index    int
	filename string
	fullpath string
}

type manifest struct {
	Size    int
	Entries []*entry
}

func parseManifestLine(line []byte) (*entry, error) {
	if !utf8.Valid(line) {
		return nil, errors.New("invalid UTF-8")
	}
	if i := bytes.IndexByte(line, '#'); i != -1 {
		line = line[:i]
	}
	fields := bytes.Fields(line)
	if len(fields) == 0 {
		return nil, nil
	}
	if len(fields) != 2 {
		return nil, fmt.Errorf("got %d fields, expected exactly 2", len(fields))
	}
	ident := string(fields[0])
	if !validIdent.MatchString(ident) {
		return nil, fmt.Errorf("invalid identifier: %q", ident)
	}
	filename := path.Clean(string(fields[1]))
	if path.IsAbs(filename) {
		return nil, errors.New("path is absolute")
	}
	return &entry{Ident: ident, filename: filename}, nil
}

func readManifest(filename string) (*manifest, error) {
	var entries []*entry
	fp, err := os.Open(filename)
	if err != nil {
		return nil, err
	}
	defer fp.Close()
	sc := bufio.NewScanner(fp)
	for lineno := 1; sc.Scan(); lineno++ {
		e, err := parseManifestLine(sc.Bytes())
		if err != nil {
			return nil, fmt.Errorf("%s:%d: %w", filename, lineno, err)
		}
		if e != nil {
			e.Index = len(entries) + 1
			entries = append(entries, e)
		}
	}
	if err := sc.Err(); err != nil {
		return nil, err
	}
	return &manifest{
		Size:    len(entries) + 1,
		Entries: entries,
	}, nil
}

func matchInputs(mn *manifest, inputs []string) error {
	eindex := make(map[string]int, len(mn.Entries))
	for i, e := range mn.Entries {
		if _, ok := eindex[e.filename]; ok {
			return fmt.Errorf("multiple entries with path: %q", e.filename)
		}
		eindex[e.filename] = i
	}
	for _, filename := range inputs {
		suffix := path.Clean(filepath.FromSlash(filename))
		for {
			if idx, ok := eindex[suffix]; ok {
				e := mn.Entries[idx]
				if e.fullpath != "" {
					return fmt.Errorf("multiple files for %q: %q and %q",
						suffix, e.fullpath, filename)
				}
				e.fullpath = filename
				break
			}
			i := strings.IndexByte(suffix, '/')
			if i == -1 {
				return fmt.Errorf("unknown input file: %q", filename)
			}
			suffix = suffix[i+1:]
		}
	}
	return nil
}

const tmplText = `/* This file is automatically generated. */
#pragma once
#define PAK_SIZE {{.Size}}
{{- range .Entries}}
#define {{.Ident}} {{.Index}}
{{- end}}
`

func writeHeader(filename string, mn *manifest) error {
	tmpl, err := template.New("header").Parse(tmplText)
	if err != nil {
		return fmt.Errorf("could not parse template: %v", err)
	}
	fp, err := os.Create(filename)
	if err != nil {
		return err
	}
	defer fp.Close()
	wr := bufio.NewWriter(fp)
	if err := tmpl.Execute(wr, mn); err != nil {
		return fmt.Errorf("could not execute template: %v", err)
	}
	if err := wr.Flush(); err != nil {
		return err
	}
	return fp.Close()
}

func writeData(filename string, mn *manifest) error {
	count := len(mn.Entries)
	type dinfo struct {
		data []byte
		pos  int
	}
	data := make([]dinfo, count)
	for i, e := range mn.Entries {
		if e.fullpath == "" {
			return fmt.Errorf("no such file found: %q", e.filename)
		}
		odata, err := ioutil.ReadFile(e.fullpath)
		if err != nil {
			return err
		}
		data[i] = dinfo{data: odata}
	}
	const maxSize = 128 * 1024 * 1024
	const hsz = 8
	header := make([]byte, 8*count)
	pos := len(header)
	for i, d := range data {
		h := header[i*hsz : (i+1)*hsz : (i+1)*hsz]
		binary.BigEndian.PutUint32(h[0:4], uint32(pos))
		binary.BigEndian.PutUint32(h[4:8], uint32(len(d.data)))
		data[i].pos = pos
		pos += len(d.data)
		pos = (pos + 1) &^ 1
		if pos > maxSize {
			return fmt.Errorf("data too large: %d bytes", pos)
		}
	}
	adata := make([]byte, pos)
	copy(adata, header)
	for _, d := range data {
		copy(adata[d.pos:], d.data)
	}
	return ioutil.WriteFile(filename, adata, 0666)
}

func mainE() error {
	flag.Parse()
	args := flag.Args()
	if len(args) == 0 {
		fmt.Fprintln(os.Stderr,
			"Usage: makepak <data-out> <header-out> <manifest> <input>...")
		os.Exit(1)
	}
	if len(args) < 3 {
		return fmt.Errorf("got %d arguments, expect at least 3", len(args))
	}
	outData := args[0]
	outHeader := args[1]
	inManifest := args[2]
	inputs := args[3:]

	mn, err := readManifest(inManifest)
	if err != nil {
		return err
	}
	if err := matchInputs(mn, inputs); err != nil {
		return err
	}
	if err := writeHeader(outHeader, mn); err != nil {
		return err
	}
	if err := writeData(outData, mn); err != nil {
		return err
	}
	return nil
}

func main() {
	if err := mainE(); err != nil {
		fmt.Fprintln(os.Stderr, "Error:", err)
		os.Exit(1)
	}
}
