package main

import (
	"bufio"
	"bytes"
	"encoding/binary"
	"errors"
	"flag"
	"fmt"
	"io/ioutil"
	"os"
	"path"
	"path/filepath"
	"regexp"
	"strings"
	"text/template"
	"unicode/utf8"

	"thornmarked/tools/audio"
	"thornmarked/tools/getpath"
)

type stringArrayValue struct {
	value   *[]string
	changed bool
}

func (v *stringArrayValue) String() string {
	if v.value == nil {
		return ""
	}
	return strings.Join(*v.value, ",")
}

func (v *stringArrayValue) Set(s string) error {
	if v.changed {
		*v.value = append(*v.value, s)
	} else {
		*v.value = []string{s}
		v.changed = true
	}
	return nil
}

func (v *stringArrayValue) Get() interface{} {
	return *v.value
}

// =============================================================================

type datatype uint32

const (
	typeUnknown datatype = iota
	typeData
	typeTrack
	typeModel
	typeTexture
)

var types = [...]string{
	typeData:    "data",
	typeTrack:   "track",
	typeModel:   "model",
	typeTexture: "texture",
}

var typeSlotCount = [...]int{
	typeData:    1,
	typeTrack:   2,
	typeModel:   1,
	typeTexture: 1,
}

func parseType(s string) (t datatype, err error) {
	if s != "" {
		for i, ts := range types {
			if strings.EqualFold(s, ts) {
				return datatype(i), nil
			}
		}
	}
	return typeUnknown, fmt.Errorf("unknown data type: %q", s)
}

var validIdent = regexp.MustCompile("^[A-Za-z][A-Za-z0-9_]*$")

type entry struct {
	dtype    datatype
	Ident    string
	Index    int
	filename string
	fullpath string
}

type manifest struct {
	Size    int
	Entries []*entry
}

func parseManifestLine(line []byte) (*entry, error) {
	if !utf8.Valid(line) {
		return nil, errors.New("invalid UTF-8")
	}
	if i := bytes.IndexByte(line, '#'); i != -1 {
		line = line[:i]
	}
	fields := bytes.Fields(line)
	if len(fields) == 0 {
		return nil, nil
	}
	if len(fields) != 3 {
		return nil, fmt.Errorf("got %d fields, expected exactly 3", len(fields))
	}
	dt, err := parseType(string(fields[0]))
	if err != nil {
		return nil, err
	}
	ident := string(fields[1])
	if !validIdent.MatchString(ident) {
		return nil, fmt.Errorf("invalid identifier: %q", ident)
	}
	filename := path.Clean(string(fields[2]))
	if path.IsAbs(filename) {
		return nil, errors.New("path is absolute")
	}
	return &entry{
		dtype:    dt,
		Ident:    ident,
		filename: filename,
	}, nil
}

func readManifest(filename string) (*manifest, error) {
	var entries []*entry
	fp, err := os.Open(filename)
	if err != nil {
		return nil, err
	}
	defer fp.Close()
	sc := bufio.NewScanner(fp)
	size := 1
	for lineno := 1; sc.Scan(); lineno++ {
		e, err := parseManifestLine(sc.Bytes())
		if err != nil {
			return nil, fmt.Errorf("%s:%d: %w", filename, lineno, err)
		}
		if e != nil {
			sc := typeSlotCount[e.dtype]
			if sc < 1 {
				panic("bad dtype")
			}
			e.Index = size
			entries = append(entries, e)
			size += sc
		}
	}
	if err := sc.Err(); err != nil {
		return nil, err
	}
	return &manifest{
		Size:    size,
		Entries: entries,
	}, nil
}

func resolveInputs(mn *manifest, dirs []string) error {
	for _, e := range mn.Entries {
		var fullpath string
		for _, dir := range dirs {
			p := filepath.Join(dir, e.filename)
			if _, err := os.Stat(p); err == nil {
				fullpath = p
				break
			}
		}
		if fullpath == "" {
			return fmt.Errorf("could not find file: %q", e.filename)
		}
		e.fullpath = fullpath
	}
	return nil
}

const tmplText = `/* This file is automatically generated. */
#pragma once
#define PAK_SIZE {{.Size}}
{{- range .Entries}}
#define {{.Ident}} {{.Index}}
{{- end}}
`

func writeHeader(filename string, mn *manifest) error {
	tmpl, err := template.New("header").Parse(tmplText)
	if err != nil {
		return fmt.Errorf("could not parse template: %v", err)
	}
	fp, err := os.Create(filename)
	if err != nil {
		return err
	}
	defer fp.Close()
	wr := bufio.NewWriter(fp)
	if err := tmpl.Execute(wr, mn); err != nil {
		return fmt.Errorf("could not execute template: %v", err)
	}
	if err := wr.Flush(); err != nil {
		return err
	}
	return fp.Close()
}

func checkMagic(data []byte, magic string, n int) error {
	if len(data) < n {
		return errors.New("file too short")
	}
	expect := make([]byte, n)
	dmagic := data[:n]
	if !bytes.Equal(dmagic[:len(magic)], []byte(magic)) {
		return fmt.Errorf("invalid header %q, expect %q", dmagic, expect)
	}
	return nil
}

func getData(e *entry, data []byte) ([][]byte, error) {
	switch e.dtype {
	case typeData:
		return [][]byte{data}, nil
	case typeTrack:
		tr, err := audio.ReadTrack(data)
		if err != nil {
			return nil, err
		}
		return [][]byte{tr.Codebook, tr.Data}, nil
	case typeModel:
		if err := checkMagic(data, "Model", 16); err != nil {
			return nil, err
		}
		return [][]byte{data[16:]}, nil
	case typeTexture:
		if err := checkMagic(data, "Texture", 16); err != nil {
			return nil, err
		}
		return [][]byte{data[16:]}, nil
	default:
		panic("bad type")
	}
}

func writeData(filename string, mn *manifest) error {
	type dinfo struct {
		data []byte
		pos  int
	}
	var data []dinfo
	const (
		hsz     = 8
		maxSize = 128 * 1024 * 1024
	)
	pos := (mn.Size - 1) * hsz
	for _, e := range mn.Entries {
		if len(data)+1 != e.Index {
			panic("out of sync with pak index")
		}
		if e.fullpath == "" {
			return fmt.Errorf("no such file found: %q", e.filename)
		}
		odata, err := ioutil.ReadFile(e.fullpath)
		if err != nil {
			return fmt.Errorf("could not load %s: %w", e.filename, err)
		}
		chunks, err := getData(e, odata)
		if err != nil {
			return fmt.Errorf("could not parse %s: %w", e.filename, err)
		}
		for _, chunk := range chunks {
			pos = (pos + 1) &^ 1
			data = append(data, dinfo{chunk, pos})
			pos += len(chunk)
		}
		if pos > maxSize {
			return fmt.Errorf("data too large: %d bytes", pos)
		}
	}
	if len(data)+1 != mn.Size {
		panic("out of sync with pak index")
	}
	pdata := make([]byte, pos)
	for i, d := range data {
		h := pdata[i*hsz : (i+1)*hsz : (i+1)*hsz]
		binary.BigEndian.PutUint32(h[0:4], uint32(d.pos))
		binary.BigEndian.PutUint32(h[4:8], uint32(len(d.data)))
		copy(pdata[d.pos:], d.data)
	}
	return ioutil.WriteFile(filename, pdata, 0666)
}

func mainE() error {
	var dirs []string
	flag.Var(&stringArrayValue{value: &dirs}, "dir", "search for files in")
	manifestFlag := flag.String("manifest", "", "input manifest file")
	dataFlag := flag.String("out-data", "", "input manifest file")
	headerFlag := flag.String("out-header", "", "output header file")
	flag.Parse()
	if *manifestFlag == "" {
		fmt.Fprint(os.Stderr,
			"Usage:\n"+
				"  makepak [-dir <dir> ...] -manifest=<manifest>\n"+
				"          -data-out=<file> -header-out=<file>\n")
		os.Exit(1)
	}
	if args := flag.Args(); len(args) != 0 {
		return fmt.Errorf("unexpected argument: %q", args[0])
	}
	inManifest := getpath.GetPath(*manifestFlag)
	outData := getpath.GetPath(*dataFlag)
	outHeader := getpath.GetPath(*headerFlag)
	if inManifest == "" {
		return errors.New("missing required flag -manifest")
	}

	mn, err := readManifest(inManifest)
	if err != nil {
		return err
	}
	if outHeader != "" {
		if err := writeHeader(outHeader, mn); err != nil {
			return err
		}
	}
	if outData != "" {
		if err := resolveInputs(mn, dirs); err != nil {
			return err
		}
		if err := writeData(outData, mn); err != nil {
			return err
		}
	}
	return nil
}

func main() {
	if err := mainE(); err != nil {
		fmt.Fprintln(os.Stderr, "Error:", err)
		os.Exit(1)
	}
}
